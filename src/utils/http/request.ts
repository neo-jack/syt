// 从 'axios' 库中导入 axios 对象。
// 1. 代码含义: 引入一个叫做 axios 的第三方库。
// 2. 代码目的: axios 是一个专门用来帮助我们和服务器进行“沟通”（发送网络请求）的工具。前端项目需要从服务器获取数据，或者把用户的数据提交到服务器，都可以用它来完成。
// 3. 实现功能: 这行代码让我们可以使用 axios 提供的所有功能，比如创建请求、设置超时时间等。
import axios from "axios";

// 从 'antd' UI 组件库中导入 message 组件。
// 1. 代码含义: 引入一个叫做 antd 的界面库里的 `message` 组件。
// 2. 代码目的: antd 是一个流行的 React 界面库，提供了很多现成的、漂亮的组件。`message` 组件专门用来在页面顶部弹出一个小提示，告诉用户操作的结果是成功了还是失败了。
// 3. 实现功能: 引入后，我们就可以在代码里调用 `message.success('操作成功')` 或 `message.error('出错了')` 这样的方法来给用户反馈。
import { message } from "antd";

// 从我们项目中的 Redux store 模块导入 store。
// 1. 代码含义: 从我们自己项目里的 `@/app/store.ts` 文件中，引入一个叫做 `store` 的东西。
// 2. 代码目的: `store` 是我们整个应用的“中央数据仓库”（使用的是 Redux 这个状态管理工具）。它存放着所有页面都可能需要共享的数据，比如当前用户的登录信息、身份令牌（token）等。
// 3. 实现功能: 引入 `store` 后，我们就可以在这个文件里读取仓库中的数据，比如获取用户的 token。
import { store } from "@/app/store";

// 这是一个 TypeScript 的接口（interface）定义，被注释掉了，所以目前没有生效。
// 1. 代码含义: 定义一个数据格式规范，叫做 `ResponseData`。
// 2. 代码目的: 它的作用是告诉程序，我们期望从服务器收到的数据应该长什么样，比如必须包含一个数字类型的 `code`，一个字符串类型的 `message`，以及一个类型不确定的核心数据 `data`。
// 3. 实现功能: 如果启用这个接口，它能帮助我们在写代码的时候获得更好的类型提示和错误检查，让代码更健壮。
// interface ResponseData<T> {
//   code: number;
//   data: T;
//   message: string;
// }

// 使用 axios.create 方法创建一个新的 axios 实例（可以理解为 axios 的一个副本）。
// 1. 代码含义: 调用 axios 的 `create` 方法，创建一个我们自己的、定制化的网络请求工具，并取名为 `request`。
// 2. 代码目的: 我们不直接使用原始的 `axios`，而是创建一个副本。这样做的好处是，我们可以给这个副本设置一些专属的配置，这些配置只会对我们项目里的请求生效，不会影响到其他可能用到 axios 的地方。
// 3. 实现功能: `request` 变量现在就是一个功能和 `axios` 一样，但带有我们自定义配置的请求工具。之后我们项目里所有的网络请求，都将通过这个 `request` 来发送。
const request = axios.create({
  // 在这里进行一些所有请求都会用到的公共配置。

  // `baseURL` 设置了请求的基础 URL 地址。
  // 1. 代码含义: 设置一个基础的服务器地址。
  // 2. 代码目的: 这样我们在写具体请求时，就只需要写接口的路径，而不用每次都写完整的服务器域名和端口，让代码更简洁。
  // 3. 实现功能: 比如 `baseURL` 设置为 "/api"，当请求 `/user/list` 时，实际发出的请求地址会自动拼接成 `/api/user/list`。`process.env.REACT_APP_API` 是一个环境变量，可以根据是开发环境还是线上环境，自动切换到不同的服务器地址。
  baseURL: process.env.REACT_APP_API, // 最终请求地址 = baseURL + 请求的url

  // `timeout` 设置了请求的超时时间，单位是毫秒。
  // 1. 代码含义: 设置一个请求的“耐心”上限。
  // 2. 代码目的: 防止因为服务器太慢或网络不好，导致程序一直卡在等待响应的阶段。
  // 3. 实现功能: 这里设置为 10000 毫秒（10 秒）。如果一个请求发出去后，超过 10 秒还没收到服务器的响应，这个请求就会被自动算作失败。
  timeout: 10000,

  // `headers` 可以用来设置所有请求都共有的请求头信息。这里暂时没有配置。
  // headers: {},
});

// 设置请求拦截器。
// 1. 代码含义: 给我们创建的 `request` 工具设置一个“请求守卫”。
// 2. 代码目的: 这个“守卫”会在我们每次发送请求之前，把请求拦下来，让我们有机会对请求进行最后的检查或修改。最常见的用途就是在这里统一给请求加上用户的身份令牌（token）。
// 3. 实现功能: 下面 `use` 里面的那个函数，会在每次请求发往服务器之前被执行。
request.interceptors.request.use((config) => {
  // 这个函数会在每次发送请求前被调用。`config` 对象包含了本次请求的所有配置信息（如 url, method, headers 等）。

  // 从 Redux store 中获取用户 token。
  // 1. 代码含义: 从“中央数据仓库”里获取当前用户的 token。
  // 2. 代码目的: token 是用户登录成功后服务器发给我们的一个“通行证”。之后每次向服务器请求数据，我们都得带上这个通行证，服务器才知道我们是谁，有没有权限访问。
  // 3. 实现功能: `store.getState()` 会拿到整个应用当前的所有数据，然后我们从中找到 user 这个部分，再取出里面的 token。
  const token = store.getState().user.token;

  // 判断 token 是否存在。用户登录后，我们就会把 token 存到 Redux store 中。
  // 1. 代码含义: 检查一下我们是否成功拿到了 token。
  // 2. 代码目的: 只有在用户登录了（即 token 存在）的情况下，我们才需要把 token 加到请求里。
  // 3. 实现功能: 如果 `token` 变量里有值，就执行大括号里的代码。
  if (token) {
    // 如果 token 存在，就将它添加到这次请求的请求头（headers）中。
    // 1. 代码含义: 把 token 放进请求的“信封”（请求头）里。
    // 2. 代码目的: 服务器会检查“信封”里的这个 `token` 字段来验证用户的身份。
    // 3. 实现功能: 这行代码修改了请求的配置对象 `config`，在它的 `headers` 属性里，增加了一个叫做 `token` 的字段，值就是我们拿到的用户 token。
    (config.headers as any).token = token;
  }

  // 修改完 `config` 后，必须将它返回。
  // 1. 代码含义: 把修改好的请求配置还给“守卫”。
  // 2. 代码目的: “守卫”必须拿到返回的配置，才能用这个最新的配置去真正地发送请求。
  // 3. 实现功能: `return config;` 就像是给请求放行，让它继续旅程。
  return config;
});

// 设置响应拦截器。
// 1. 代码含义: 给我们的 `request` 工具设置一个“响应守卫”。
// 2. 代码目的: 这个“守卫”会在服务器把数据返回给我们之后，但在我们的代码处理这些数据之前，先把响应拦下来。这让我们有机会对所有响应进行统一的预处理，比如判断操作是否真的成功了，或者统一处理各种错误。
// 3. 实现功能: `use` 接收两个函数，第一个函数用于处理成功的响应，第二个用于处理失败的响应。
request.interceptors.response.use(
  // 第一个函数是处理“成功”的响应。
  // 这里的“成功”指的是 HTTP 状态码是 2xx（例如 200 OK），表示请求已成功被服务器接收、理解、并接受。
  (response) => {
    // `response` 对象包含了服务器返回的所有信息，包括状态码、响应头、以及响应体（`data`）。
    // 我们和后端约定，响应体 `response.data` 中会包含一个业务状态码 `code`。
    // 1. 代码含义: 检查服务器返回数据里的业务状态码 `code` 是不是 200。
    // 2. 代码目的: 有时候，虽然网络请求本身是通的（HTTP 200），但业务上可能是失败的（比如“用户名已存在”）。我们通过后端定义的 `code` 来判断业务是否真正成功。
    // 3. 实现功能: 如果 `code` 等于 200，说明一切顺利。
    if (response.data.code === 200) {
      // 如果业务状态码 `code` 是 200，说明业务逻辑处理成功（比如登录成功、获取数据成功）。
      // 1. 代码含义: 直接返回响应数据中的核心数据部分 `response.data.data`。
      // 2. 代码目的: 服务器返回的数据通常会包装在一个对象里，像 `{ code: 200, message: '成功', data: { ... } }`。我们真正关心的只是 `data` 里面的内容。
      // 3. 实现功能: 这样做可以简化后续代码，让调用这个请求的地方能直接拿到最需要的数据，而不用自己再去解析一层。
      return response.data.data;
    } else {
      // 如果 `code` 不是 200，说明业务逻辑上出了问题（比如密码错误、参数无效等）。
      // 1. 代码含义: 从响应数据中提取错误信息。
      // 2. 代码目的: 拿到后端告诉我们的具体错误原因，然后展示给用户。
      // 3. 实现功能: 优先使用 `response.data.data` 作为错误信息，如果它不存在，就用 `response.data.message`。
      const errorMsg = response.data.data || response.data.message
      // 使用 antd 的 `message.error` 方法，在页面上弹出一个红色的错误提示框，告诉用户发生了什么错误。
      message.error(errorMsg);
      // 返回一个被拒绝的 Promise，并把错误信息传递出去。
      // 1. 代码含义: 主动制造一个“错误”。
      // 2. 代码目的: 告诉调用这个请求的代码，操作失败了，不要再继续执行成功的逻辑了，而是应该去执行失败的逻辑（比如 `.catch` 部分）。
      // 3. 实现功能: 这会中断 Promise 链，让程序跳到错误处理分支。
      return Promise.reject(errorMsg);
    }
  },
  // 第二个函数是处理“失败”的响应。
  // 这里的“失败”指的是网络层面或服务器层面的错误，比如请求超时、网络中断、服务器返回 404 (找不到页面) 或 501 (服务器内部错误) 等。
  (error) => {
    // `error` 对象包含了详细的错误信息。
    // 1. 代码含义: 使用 antd 的 `message.error` 在页面上提示用户请求失败了。
    // 2. 代码目的: 给用户一个明确的反馈，告诉他们当前的操作因为网络或服务器问题没能完成。
    // 3. 实现功能: 弹出错误提示，内容是 `error.message`，如果这个 message 不存在，就显示默认的'请求失败'。
    message.error(error.message || '请求失败');
    // 同样返回一个被拒绝的 Promise，将错误对象传递出去。
    // 1. 代码含义: 将这个网络或服务器错误继续向外传递。
    // 2. 代码目的: 让调用请求的地方也能捕获到这个错误，从而可以根据需要做一些额外的处理，比如记录错误日志。
    // 3. 实现功能: 这会中断 Promise 链，并将包含详细技术信息的 `error` 对象传递到 `.catch` 分支。
    return Promise.reject(error);
  }
);

// 将我们精心配置好的 axios 实例 `request` 导出。
// 1. 代码含义: 把我们这个配置好的 `request` 工具暴露出去。
// 2. 代码目的: 这样，在项目中的其他任何文件里，就都可以通过 `import` 语句来使用它了。
// 3. 实现功能: `export default` 是一种导出模块的语法，它指定了 `request` 是这个文件的默认导出项。
export default request;
